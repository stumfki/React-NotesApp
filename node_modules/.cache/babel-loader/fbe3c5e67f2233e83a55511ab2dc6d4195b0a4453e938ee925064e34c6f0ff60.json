{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\nfunction getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = function (c) {\n    return c === \" \" || c.charCodeAt(0) === 10;\n  };\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n  // iterate to the right\n  for (var i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n  return {\n    start: start,\n    end: end\n  };\n}\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\nfunction selectWord(_a) {\n  var text = _a.text,\n    selection = _a.selection;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n  if (startPosition === 0) return 0;\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n  if (startPosition === text.length - 1) return 0;\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;","map":{"version":3,"names":["Object","defineProperty","exports","value","getBreaksNeededForEmptyLineAfter","getBreaksNeededForEmptyLineBefore","selectWord","getSurroundingWord","text","position","Error","isWordDelimiter","c","charCodeAt","start","end","length","i","_a","selection","startPosition","neededBreaks","isInFirstLine","isInLastLine"],"sources":["C:/Users/Din/Desktop/web/React/notesapp/node_modules/react-mde/lib/js/util/MarkdownUtil.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\nfunction getSurroundingWord(text, position) {\n    if (!text)\n        throw Error(\"Argument 'text' should be truthy\");\n    var isWordDelimiter = function (c) { return c === \" \" || c.charCodeAt(0) === 10; };\n    // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n    var start = 0;\n    // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n    var end = text.length;\n    // iterate to the left\n    for (var i = position; i - 1 > -1; i--) {\n        if (isWordDelimiter(text[i - 1])) {\n            start = i;\n            break;\n        }\n    }\n    // iterate to the right\n    for (var i = position; i < text.length; i++) {\n        if (isWordDelimiter(text[i])) {\n            end = i;\n            break;\n        }\n    }\n    return { start: start, end: end };\n}\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\nfunction selectWord(_a) {\n    var text = _a.text, selection = _a.selection;\n    if (text && text.length && selection.start === selection.end) {\n        // the user is pointing to a word\n        return getSurroundingWord(text, selection.start);\n    }\n    return selection;\n}\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === 0)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInFirstLine = true;\n    for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n        switch (text.charCodeAt(i)) {\n            case 32: // blank space\n                continue;\n            case 10: // line break\n                neededBreaks--;\n                isInFirstLine = false;\n                break;\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInFirstLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === text.length - 1)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInLastLine = true;\n    for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n        switch (text.charCodeAt(i)) {\n            case 32:\n                continue;\n            case 10: {\n                neededBreaks--;\n                isInLastLine = false;\n                break;\n            }\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInLastLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}